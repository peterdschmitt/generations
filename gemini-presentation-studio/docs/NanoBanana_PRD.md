# Nano Banana Prompt Library

## Product Requirements Document

---

## 1. Overview

The Nano Banana Prompt Library is a React/TypeScript application that aggregates, manages, and displays AI image generation prompts from multiple GitHub repositories. It integrates with Airtable for persistent storage and provides a horizontal swipe interface for browsing prompts.

**Target Users:** Marketers, designers, and content creators using Gemini 2.5 Flash for image generation.

---

## 2. Core Features

### 2.1 GitHub Source Management
- Add/remove GitHub repositories as prompt sources
- Toggle sources on/off without deletion
- Display prompt count per repository
- Sync all enabled sources with one click
- Input format: `owner/repo`

### 2.2 Horizontal Swipe Interface
- Single card view with left/right navigation
- Keyboard navigation (‚Üê ‚Üí arrows)
- Progress indicator dots
- Card counter (e.g., "3 / 50")
- Click-to-navigate dots

### 2.3 Prompt Display
- Generated image preview (Gemini output)
- Full prompt text in monospace font
- Category and reference requirement badges
- One-click copy to clipboard
- Tags for filtering
- Author attribution with link

---

## 3. Airtable Schema

**Table Name:** `NanoBanana`

| Field Name | Type | Description |
|------------|------|-------------|
| Case ID | Formula/Text | MD5 hash of prompt for deduplication (Primary Key) |
| Case Number | Auto Number | Sequential case identifier |
| Title | Single Line Text | Original title (may be Chinese) |
| Title (EN) | Single Line Text | English translation of title |
| Prompt | Long Text | Full prompt text (original language) |
| Prompt (EN) | Long Text | English translation of prompt |
| Author | Single Line Text | GitHub username of contributor |
| Author URL | URL | Link to author's GitHub profile |
| Source Repo | Single Line Text | Repository in `owner/repo` format |
| Source URL | URL | Direct link to source file on GitHub |
| Gemini Image URL | URL | URL of image generated by Gemini |
| GPT-4o Image URL | URL | URL of image generated by GPT-4o |
| Gemini Image | Attachment | Uploaded Gemini output image |
| GPT-4o Image | Attachment | Uploaded GPT-4o output image |
| Reference Required | Checkbox | True if prompt needs reference image |
| Reference Note | Single Line Text | Instructions for reference image |
| Tags | Multiple Select | Categorization tags |
| Category | Single Select | Primary category classification |
| Scraped At | Date | Timestamp of when prompt was scraped |

### 3.1 Category Values

Single select field options:
- Product Photography
- Advertisements
- Infographics
- Social Media
- Presentations
- Portraits
- Real Estate
- Photo Enhancement

### 3.2 Common Tags

Multiple select field options:
- Product, Miniature, Studio, E-Commerce, Isolation
- Flowchart, Business, Corporate, McKinsey
- Instagram, LinkedIn, 3D, Chibi, Headshot
- Surreal, Creative, Diorama, Brand
- Fashion, Try-On, Neon, Futuristic

---

## 4. Technical Architecture

### 4.1 Technology Stack

| Layer | Technology |
|-------|------------|
| Frontend | React 18+ with TypeScript |
| State Management | React hooks (useState, useEffect, useRef) |
| Database | Airtable (via REST API) |
| Data Source | GitHub API (raw content fetching) |
| Styling | CSS-in-JS (inline styles) |

### 4.2 File Structure

```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ NanoBananaSwipe.tsx    # Main swipe UI component
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ airtableService.ts     # Airtable CRUD operations
‚îÇ   ‚îî‚îÄ‚îÄ githubService.ts       # GitHub scraping logic
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ nanobanana.ts          # TypeScript interfaces
‚îî‚îÄ‚îÄ config/
    ‚îî‚îÄ‚îÄ repositories.ts        # Default GitHub sources
```

---

## 5. Code Samples

### 5.1 TypeScript Interfaces

```typescript
// types/nanobanana.ts

export interface NanoBananaCase {
  id: string;                    // Airtable record ID
  caseId: string;               // Case ID (MD5 hash)
  caseNumber: number;           // Case Number
  title: string;                // Title
  titleEn: string;              // Title (EN)
  prompt: string;               // Prompt
  promptEn: string;             // Prompt (EN)
  author: string;               // Author
  authorUrl: string;            // Author URL
  sourceRepo: string;           // Source Repo
  sourceUrl: string;            // Source URL
  geminiImageUrl: string;       // Gemini Image URL
  gpt4oImageUrl: string;        // GPT-4o Image URL
  geminiImage?: string;         // Gemini Image (attachment URL)
  gpt4oImage?: string;          // GPT-4o Image (attachment URL)
  referenceRequired: boolean;   // Reference Required
  referenceNote: string;        // Reference Note
  tags: string[];               // Tags
  category: string;             // Category
  scrapedAt: string;            // Scraped At
}

export interface GitHubSource {
  id: string;
  owner: string;
  repo: string;
  enabled: boolean;
  count: number;
}
```

### 5.2 Airtable Service

```typescript
// services/airtableService.ts

const AIRTABLE_API_KEY = process.env.REACT_APP_AIRTABLE_API_KEY;
const AIRTABLE_BASE_ID = process.env.REACT_APP_AIRTABLE_BASE_ID;
const TABLE_NAME = 'NanoBanana';

export async function fetchCases(): Promise<NanoBananaCase[]> {
  const url = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${TABLE_NAME}`;
  const res = await fetch(url, {
    headers: { Authorization: `Bearer ${AIRTABLE_API_KEY}` }
  });
  const data = await res.json();
  return data.records.map(mapRecordToCase);
}

export async function createCases(cases: Partial<NanoBananaCase>[]): Promise<void> {
  const url = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${TABLE_NAME}`;
  
  // Batch in groups of 10 (Airtable limit)
  for (let i = 0; i < cases.length; i += 10) {
    const batch = cases.slice(i, i + 10);
    await fetch(url, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${AIRTABLE_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        records: batch.map(c => ({ fields: mapCaseToFields(c) }))
      })
    });
    // Rate limit: 5 req/sec
    await new Promise(r => setTimeout(r, 250));
  }
}

function mapRecordToCase(record: any): NanoBananaCase {
  const f = record.fields;
  return {
    id: record.id,
    caseId: f['Case ID'] || '',
    caseNumber: f['Case Number'] || 0,
    title: f['Title'] || '',
    titleEn: f['Title (EN)'] || '',
    prompt: f['Prompt'] || '',
    promptEn: f['Prompt (EN)'] || '',
    author: f['Author'] || '',
    authorUrl: f['Author URL'] || '',
    sourceRepo: f['Source Repo'] || '',
    sourceUrl: f['Source URL'] || '',
    geminiImageUrl: f['Gemini Image URL'] || '',
    gpt4oImageUrl: f['GPT-4o Image URL'] || '',
    geminiImage: f['Gemini Image']?.[0]?.url || '',
    gpt4oImage: f['GPT-4o Image']?.[0]?.url || '',
    referenceRequired: f['Reference Required'] || false,
    referenceNote: f['Reference Note'] || '',
    tags: f['Tags'] || [],
    category: f['Category'] || '',
    scrapedAt: f['Scraped At'] || ''
  };
}

function mapCaseToFields(c: Partial<NanoBananaCase>): Record<string, any> {
  return {
    'Case ID': c.caseId,
    'Title': c.title,
    'Title (EN)': c.titleEn,
    'Prompt': c.prompt,
    'Prompt (EN)': c.promptEn,
    'Author': c.author,
    'Author URL': c.authorUrl,
    'Source Repo': c.sourceRepo,
    'Source URL': c.sourceUrl,
    'Gemini Image URL': c.geminiImageUrl,
    'GPT-4o Image URL': c.gpt4oImageUrl,
    'Reference Required': c.referenceRequired,
    'Reference Note': c.referenceNote,
    'Tags': c.tags,
    'Category': c.category,
    'Scraped At': c.scrapedAt
  };
}
```

### 5.3 GitHub Scraping Service

```typescript
// services/githubService.ts

import crypto from 'crypto';
import { NanoBananaCase, GitHubSource } from '../types/nanobanana';

export async function scrapeRepo(source: GitHubSource): Promise<Partial<NanoBananaCase>[]> {
  const readmeUrl = `https://raw.githubusercontent.com/${source.owner}/${source.repo}/main/README.md`;
  
  const res = await fetch(readmeUrl);
  if (!res.ok) {
    // Try 'master' branch if 'main' fails
    const fallbackUrl = readmeUrl.replace('/main/', '/master/');
    const fallbackRes = await fetch(fallbackUrl);
    if (!fallbackRes.ok) throw new Error(`Failed to fetch ${source.owner}/${source.repo}`);
    return parsePrompts(await fallbackRes.text(), source);
  }
  
  return parsePrompts(await res.text(), source);
}

function parsePrompts(markdown: string, source: GitHubSource): Partial<NanoBananaCase>[] {
  const cases: Partial<NanoBananaCase>[] = [];
  
  // Pattern: Look for prompt blocks in markdown
  // Common formats:
  // 1. Code blocks with prompts
  // 2. Blockquotes
  // 3. Sections with "Prompt:" labels
  
  const codeBlockRegex = /```(?:text|prompt)?\n([\s\S]*?)```/g;
  const blockquoteRegex = /^>\s*(.+)$/gm;
  
  let match;
  
  // Extract from code blocks
  while ((match = codeBlockRegex.exec(markdown)) !== null) {
    const prompt = match[1].trim();
    if (prompt.length > 50) { // Filter out short snippets
      cases.push(createCase(prompt, source));
    }
  }
  
  return cases;
}

function createCase(prompt: string, source: GitHubSource): Partial<NanoBananaCase> {
  const caseId = crypto.createHash('md5').update(prompt).digest('hex');
  
  // Extract title from first line or generate from prompt
  const title = prompt.split('\n')[0].substring(0, 100) || 'Untitled Prompt';
  
  // Detect if reference image is required
  const refKeywords = ['uploaded', 'attached', 'reference', 'image 1', 'image 2', 'your photo'];
  const referenceRequired = refKeywords.some(k => prompt.toLowerCase().includes(k));
  
  // Categorize based on keywords
  const category = detectCategory(prompt);
  const tags = extractTags(prompt);
  
  return {
    caseId,
    title,
    titleEn: title,
    prompt,
    promptEn: prompt,
    author: source.owner,
    authorUrl: `https://github.com/${source.owner}`,
    sourceRepo: `${source.owner}/${source.repo}`,
    sourceUrl: `https://github.com/${source.owner}/${source.repo}`,
    referenceRequired,
    referenceNote: referenceRequired ? 'Upload reference image' : '',
    tags,
    category,
    scrapedAt: new Date().toISOString().split('T')[0]
  };
}

function detectCategory(prompt: string): string {
  const lower = prompt.toLowerCase();
  if (lower.includes('product') || lower.includes('e-commerce')) return 'Product Photography';
  if (lower.includes('flowchart') || lower.includes('infographic') || lower.includes('chart')) return 'Infographics';
  if (lower.includes('instagram') || lower.includes('linkedin') || lower.includes('social')) return 'Social Media';
  if (lower.includes('advertisement') || lower.includes('ad ') || lower.includes('commercial')) return 'Advertisements';
  if (lower.includes('portrait') || lower.includes('headshot')) return 'Portraits';
  if (lower.includes('real estate') || lower.includes('floor plan')) return 'Real Estate';
  if (lower.includes('presentation') || lower.includes('ppt') || lower.includes('slide')) return 'Presentations';
  return 'Product Photography'; // Default
}

function extractTags(prompt: string): string[] {
  const tags: string[] = [];
  const lower = prompt.toLowerCase();
  
  const tagMap: Record<string, string> = {
    'miniature': 'Miniature',
    'studio': 'Studio',
    'e-commerce': 'E-Commerce',
    'flowchart': 'Flowchart',
    'business': 'Business',
    'corporate': 'Corporate',
    'instagram': 'Instagram',
    'linkedin': 'LinkedIn',
    '3d': '3D',
    'chibi': 'Chibi',
    'headshot': 'Headshot',
    'surreal': 'Surreal',
    'creative': 'Creative',
    'fashion': 'Fashion',
    'neon': 'Neon',
    'diorama': 'Diorama'
  };
  
  for (const [keyword, tag] of Object.entries(tagMap)) {
    if (lower.includes(keyword)) tags.push(tag);
  }
  
  return tags.slice(0, 5); // Limit to 5 tags
}
```

### 5.4 React Component (Swipe UI)

```tsx
// components/NanoBananaSwipe.tsx

import React, { useState, useEffect } from 'react';
import { NanoBananaCase, GitHubSource } from '../types/nanobanana';
import { fetchCases } from '../services/airtableService';
import { scrapeRepo } from '../services/githubService';

export default function NanoBananaSwipe() {
  const [cases, setCases] = useState<NanoBananaCase[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [sources, setSources] = useState<GitHubSource[]>([
    { id: '1', owner: 'JimmyLv', repo: 'awesome-nano-banana', enabled: true, count: 0 },
    { id: '2', owner: 'ZeroLu', repo: 'awesome-nanobanana-pro', enabled: true, count: 0 },
  ]);
  const [copied, setCopied] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadCases();
  }, []);

  useEffect(() => {
    const handleKey = (e: KeyboardEvent) => {
      if (e.key === 'ArrowRight') goNext();
      if (e.key === 'ArrowLeft') goPrev();
    };
    window.addEventListener('keydown', handleKey);
    return () => window.removeEventListener('keydown', handleKey);
  }, [currentIndex, cases.length]);

  const loadCases = async () => {
    setLoading(true);
    try {
      const data = await fetchCases();
      setCases(data);
    } catch (err) {
      console.error('Failed to load cases:', err);
    }
    setLoading(false);
  };

  const goNext = () => setCurrentIndex(i => Math.min(i + 1, cases.length - 1));
  const goPrev = () => setCurrentIndex(i => Math.max(i - 1, 0));

  const copyPrompt = () => {
    navigator.clipboard.writeText(cases[currentIndex].prompt);
    setCopied(true);
    setTimeout(() => setCopied(false), 1500);
  };

  const currentCase = cases[currentIndex];

  if (loading) return <div>Loading...</div>;
  if (!currentCase) return <div>No prompts found</div>;

  return (
    <div className="container">
      {/* Header */}
      <header>
        <div className="logo">üçå nano banana</div>
        <div className="counter">{currentIndex + 1} / {cases.length}</div>
      </header>

      {/* Card */}
      <div className="card-container">
        <button onClick={goPrev} disabled={currentIndex === 0}>‚Äπ</button>
        
        <div className="card">
          <div className="card-image">
            {currentCase.geminiImage ? (
              <img src={currentCase.geminiImage} alt={currentCase.title} />
            ) : (
              <div className="placeholder">üñºÔ∏è</div>
            )}
            <div className="badges">
              <span className="badge">{currentCase.category}</span>
              {currentCase.referenceRequired && <span className="badge ref">ref</span>}
            </div>
          </div>
          
          <div className="card-content">
            <h2>{currentCase.title}</h2>
            <div className="prompt-box">
              <p>{currentCase.prompt}</p>
            </div>
            {currentCase.referenceNote && (
              <div className="ref-note">üí° {currentCase.referenceNote}</div>
            )}
            <div className="tags">
              {currentCase.tags.map(t => <span key={t}>#{t}</span>)}
            </div>
            <div className="footer">
              <span>@{currentCase.author}</span>
              <button onClick={copyPrompt}>
                {copied ? '‚úì Copied' : 'Copy Prompt'}
              </button>
            </div>
          </div>
        </div>
        
        <button onClick={goNext} disabled={currentIndex === cases.length - 1}>‚Ä∫</button>
      </div>

      {/* Dots */}
      <div className="dots">
        {cases.map((_, i) => (
          <button
            key={i}
            className={i === currentIndex ? 'active' : ''}
            onClick={() => setCurrentIndex(i)}
          />
        ))}
      </div>
    </div>
  );
}
```

---

## 6. API Integration

### 6.1 Airtable API

| Property | Value |
|----------|-------|
| Base URL | `https://api.airtable.com/v0/{BASE_ID}/NanoBanana` |
| Authentication | Bearer token in Authorization header |
| Rate Limit | 5 requests/second |
| Batch Size | 10 records per request (max) |

**Headers:**
```
Authorization: Bearer {AIRTABLE_API_KEY}
Content-Type: application/json
```

### 6.2 GitHub API

| Property | Value |
|----------|-------|
| Raw Content URL | `https://raw.githubusercontent.com/{owner}/{repo}/main/README.md` |
| Rate Limit (Unauthenticated) | 60 requests/hour |
| Rate Limit (With Token) | 5,000 requests/hour |

---

## 7. Default GitHub Sources

| Repository | Est. Prompts | Status |
|------------|--------------|--------|
| JimmyLv/awesome-nano-banana | ~100 | Active |
| ZeroLu/awesome-nanobanana-pro | ~50 | Active |
| PicoTrex/Awesome-Nano-Banana-images | ~110 | Active |
| Super-Maker-AI/awesome-nano-banana | ~30 | Active |
| muset-ai/awesome-nano-banana-pro | ~50 | Active |

---

## 8. Environment Variables

```bash
# .env
REACT_APP_AIRTABLE_API_KEY=pat...
REACT_APP_AIRTABLE_BASE_ID=app...
REACT_APP_GITHUB_TOKEN=ghp_...  # Optional, for higher rate limits
```

---

## 9. UI Specifications

### 9.1 Color Palette

| Element | Color |
|---------|-------|
| Background | `#0a0a0b` (near black) |
| Card Background | `#111113` |
| Border | `#1a1a1c` |
| Primary Text | `#e5e5e5` |
| Secondary Text | `#666666` |
| Muted Text | `#333333` |
| Accent Blue | `#2563eb` |
| Warning Orange | `#f97316` |
| Success Green | `#22c55e` |

### 9.2 Typography

| Element | Specification |
|---------|---------------|
| Font Family | `-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif` |
| Monospace | `ui-monospace, 'SF Mono', 'Fira Code', monospace` |
| Title | 13-14px, weight 600 |
| Body | 10-11px, weight 400 |
| Labels | 8-9px, weight 400 |

### 9.3 Card Layout

| Element | Specification |
|---------|---------------|
| Max Width | 680px |
| Image Section | 220-260px fixed width |
| Content Padding | 12-16px |
| Border Radius | 6-8px |
| Gap | 10-12px |

---

## 10. Implementation Steps

1. **Set up Airtable base** with NanoBanana table and all 19 fields
2. **Create TypeScript interfaces** matching Airtable schema
3. **Implement Airtable service** with fetch, create, and batch operations
4. **Implement GitHub service** for scraping README files
5. **Build NanoBananaSwipe component** with horizontal navigation
6. **Add source management UI** for adding/toggling GitHub repos
7. **Connect components to services** and test full flow
8. **Add environment configuration** for API keys

---

## 11. Sample Prompts

### Product Photography
```
A high-resolution advertising photograph of a realistic, miniature [PRODUCT] 
held delicately between a person's thumb and index finger. Clean and white 
background, studio lighting, soft shadows. The hand is well-groomed, natural 
skin tone, and positioned to highlight the product's shape and details.
```

### E-Commerce Isolation
```
Identify the main product in the uploaded photo. Subject Isolation: Cleanly 
extract the product, completely removing any fingers, hands, or clutter. 
Background: Place the product on a pure white studio background (RGB 255, 
255, 255) with a subtle, natural contact shadow at the base to ground it.
```

### McKinsey Flowchart
```
Convert this hand-drawn whiteboard sketch into a professional corporate 
flowchart suitable for a business presentation. Style Guide: Use a minimalist 
"McKinsey-style" aesthetic: clean lines, ample whitespace, and a sophisticated 
blue-and-gray color palette.
```

---

*End of Document*
